{"version":3,"sources":["webpack://core-next-validation/webpack/universalModuleDefinition","webpack://core-next-validation/webpack/bootstrap","webpack://core-next-validation/./src/validationError.js","webpack://core-next-validation/./src/schemaGenerator.js","webpack://core-next-validation/./src/functions.js","webpack://core-next-validation/./src/index.js","webpack://core-next-validation/./src/validationFramework.js","webpack://core-next-validation/./src/api.js","webpack://core-next-validation/./src/validatorContext.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ERROR_CODES","INVALID_TYPE","ENUM_MISMATCH","ANY_OF_MISSING","ONE_OF_MISSING","ONE_OF_MULTIPLE","NOT_PASSED","NUMBER_MULTIPLE_OF","NUMBER_MINIMUM","NUMBER_MINIMUM_EXCLUSIVE","NUMBER_MAXIMUM","NUMBER_MAXIMUM_EXCLUSIVE","NUMBER_NOT_A_NUMBER","STRING_LENGTH_SHORT","STRING_LENGTH_LONG","STRING_PATTERN","OBJECT_PROPERTIES_MINIMUM","OBJECT_PROPERTIES_MAXIMUM","OBJECT_REQUIRED","OBJECT_ADDITIONAL_PROPERTIES","OBJECT_DEPENDENCY_KEY","ARRAY_LENGTH_SHORT","ARRAY_LENGTH_LONG","ARRAY_UNIQUE","ARRAY_ADDITIONAL_ITEMS","FORMAT_CUSTOM","KEYWORD_CUSTOM","CIRCULAR_REFERENCE","UNKNOWN_PROPERTY","ErrorCodeLookup","ERROR_MESSAGES_DEFAULT","ValidationError","constructor","code","message","params","dataPath","schemaPath","subErrors","undefined","Error","err","stack","stacktrace","err2","prefixWith","dataPrefix","schemaPrefix","length","SCHEMA_HEADER","$schema","title","description","type","properties","data","dkey","obj","keys","Array","Number","String","URI_TEMPLATE_GLOBAL_MODIFIERS","+","#",".","/",";","?","&","URI_TEMPLATE_SUFFICES","*","parseURI","url","href","protocol","authority","host","hostname","port","pathname","search","hash","removeDotSegments","input","output","resolveUrl","base","normSchema","getDocumentUri","uri","isTrustedUrl","baseUrl","testUrl","remainder","schema","baseUri","id","ValidationFramework","SchemaGenerator","_validationError","_myValidator","_api2","default","addLanguage","supportsValidation","registerSchema","identity","addSchema","getSchema","getSchemas","getSchemaMap","clearSchemas","dropSchemas","validate","validateMultiple","getValidationMessages","error","generateSchema","model","_schemaGenerator2","_validatorContext","_functions","languages","createApi","language","_myContext","ValidatorContext","currentLanguage","addFormat","format","validator","messageMap","rootCode","freshApi","result","checkRecursive","banUnknownProperties","context","$ref","missing","valid","validateResult","apply","arguments","urlHistory","getSchemaUris","getMissingUris","defineKeyword","defineError","codeName","codeNumber","defaultMessage","test","langCode","reset","errorCodes","CLOSE_ENOUGH_LOW","Math","CLOSE_ENOUGH_HIGH","parent","collectMultiple","errorMessages","trackUnknownProperties","missingMap","formatValidators","schemas","errors","handleError","collectError","returnError","scanned","scannedFrozen","scannedFrozenSchemas","scannedFrozenValidationErrors","validatedSchemasKey","validationErrorsKey","knownPropertyPaths","unknownPropertyPaths","definedKeywords","notReallyPercentEncode","string","encodeURI","replace","doubleEncoded","uriTemplateSubstitution","spec","modifier","separator","prefix","shouldEscape","showVariables","trimEmptyString","varNames","varList","varSpecs","varSpecMap","varName","truncate","parts","parseInt","suffices","varSpec","subFunction","valueFunction","startIndex","isFunction","j","encodeURIComponent","first","substitution","recursiveCompare","A","B","keyword","keywordFunction","push","createError","messageParams","messageTemplate","JSON","whole","subValue","prefixErrors","unknownPath","path","resolveRefs","urls","fragment","pointerPath","decodeURIComponent","component","searchSchemas","map","filterRegExp","list","validateAll","dataPathParts","schemaPathParts","dataPointerPath","topLevel","frozenIndex","startErrorCount","scannedFrozenSchemaIndex","scannedSchemasIndex","schemaIndex","concat","indexOf","frozenSchemaIndex","configurable","e","errorCount","validateBasic","validateNumeric","validateString","validateArray","validateObject","validateCombinations","validateHypermedia","validateFormat","validateDefinedKeywords","pop","dataPart","schemaPart","slice","errorMessage","validationFunctions","func","validateType","dataType","allowedTypes","expected","validateEnum","enumVal","validateMultipleOf","validateMinMax","validateNaN","multipleOf","divisibleBy","minimum","maximum","isNaN","Infinity","validateStringLength","validateStringPattern","minLength","maxLength","RegExp","pattern","regexp","validateArrayLength","validateArrayUniqueItems","validateArrayItems","minItems","maxItems","uniqueItems","match1","match2","items","additionalItems","validateObjectMinMaxProperties","validateObjectRequiredProperties","validateObjectProperties","validateObjectDependencies","minProperties","propertyCount","maxProperties","keyPointerPath","foundMatch","patternKey","patternProperties","additionalProperties","depKey","dependencies","dep","lenth","requiredKey","validateAllOf","validateAnyOf","validateOneOf","validateNot","subSchema","oldUnknownPropertyPaths","oldKnownPropertyPaths","errorAtEnd","knownKey","unknownKey","validIndex","index1","index2","oldErrorCount","not","notErrors","links","ldo","template","UriTemplate","allPresent","ll"],"mappings":"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","file":"core-next-validation.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"core-next-validation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"core-next-validation\"] = factory();\n\telse\n\t\troot[\"core-next-validation\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const ERROR_CODES = {\n  INVALID_TYPE: 0,\n  ENUM_MISMATCH: 1,\n  ANY_OF_MISSING: 10,\n  ONE_OF_MISSING: 11,\n  ONE_OF_MULTIPLE: 12,\n  NOT_PASSED: 13,\n  // Numeric errors\n  NUMBER_MULTIPLE_OF: 100,\n  NUMBER_MINIMUM: 101,\n  NUMBER_MINIMUM_EXCLUSIVE: 102,\n  NUMBER_MAXIMUM: 103,\n  NUMBER_MAXIMUM_EXCLUSIVE: 104,\n  NUMBER_NOT_A_NUMBER: 105,\n  // String errors\n  STRING_LENGTH_SHORT: 200,\n  STRING_LENGTH_LONG: 201,\n  STRING_PATTERN: 202,\n  // Object errors\n  OBJECT_PROPERTIES_MINIMUM: 300,\n  OBJECT_PROPERTIES_MAXIMUM: 301,\n  OBJECT_REQUIRED: 302,\n  OBJECT_ADDITIONAL_PROPERTIES: 303,\n  OBJECT_DEPENDENCY_KEY: 304,\n  // Array errors\n  ARRAY_LENGTH_SHORT: 400,\n  ARRAY_LENGTH_LONG: 401,\n  ARRAY_UNIQUE: 402,\n  ARRAY_ADDITIONAL_ITEMS: 403,\n  // Custom/user-defined errors\n  FORMAT_CUSTOM: 500,\n  KEYWORD_CUSTOM: 501,\n  // Schema structure\n  CIRCULAR_REFERENCE: 600,\n  // Non-standard validation options\n  UNKNOWN_PROPERTY: 1000\n};\n\n// TODO: bundle this\nconst ERROR_MESSAGES_DEFAULT = {\n  INVALID_TYPE: \"Invalid type: {type} (expected {expected})\",\n  ENUM_MISMATCH: \"No enum match for: {value}\",\n  ANY_OF_MISSING: \"Data does not match any schemas from \\\"anyOf\\\"\",\n  ONE_OF_MISSING: \"Data does not match any schemas from \\\"oneOf\\\"\",\n  ONE_OF_MULTIPLE: \"Data is valid against more than one schema from \\\"oneOf\\\": indices {index1} and {index2}\",\n  NOT_PASSED: \"Data matches schema from \\\"not\\\"\",\n  // Numeric errors\n  NUMBER_MULTIPLE_OF: \"Value {value} is not a multiple of {multipleOf}\",\n  NUMBER_MINIMUM: \"Value {value} is less than minimum {minimum}\",\n  NUMBER_MINIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive minimum {minimum}\",\n  NUMBER_MAXIMUM: \"Value {value} is greater than maximum {maximum}\",\n  NUMBER_MAXIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive maximum {maximum}\",\n  NUMBER_NOT_A_NUMBER: \"Value {value} is not a valid number\",\n  // String errors\n  STRING_LENGTH_SHORT: \"String is too short ({length} chars), minimum {minimum}\",\n  STRING_LENGTH_LONG: \"String is too long ({length} chars), maximum {maximum}\",\n  STRING_PATTERN: \"String does not match pattern: {pattern}\",\n  // Object errors\n  OBJECT_PROPERTIES_MINIMUM: \"Too few properties defined ({propertyCount}), minimum {minimum}\",\n  OBJECT_PROPERTIES_MAXIMUM: \"Too many properties defined ({propertyCount}), maximum {maximum}\",\n  OBJECT_REQUIRED: \"Missing required property: {key}\",\n  OBJECT_ADDITIONAL_PROPERTIES: \"Additional properties not allowed\",\n  OBJECT_DEPENDENCY_KEY: \"Dependency failed - key must exist: {missing} (due to key: {key})\",\n  // Array errors\n  ARRAY_LENGTH_SHORT: \"Array is too short ({length}), minimum {minimum}\",\n  ARRAY_LENGTH_LONG: \"Array is too long ({length}), maximum {maximum}\",\n  ARRAY_UNIQUE: \"Array items are not unique (indices {match1} and {match2})\",\n  ARRAY_ADDITIONAL_ITEMS: \"Additional items not allowed\",\n  // Format errors\n  FORMAT_CUSTOM: \"Format validation failed ({message})\",\n  KEYWORD_CUSTOM: \"Keyword failed: {key} ({message})\",\n  // Schema structure\n  CIRCULAR_REFERENCE: \"Circular $refs: {urls}\",\n  // Non-standard validation options\n  UNKNOWN_PROPERTY: \"Unknown property (not in schema)\"\n};\n\nclass ValidationError { //extends Error {\n  constructor(code, message, params, dataPath, schemaPath, subErrors) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    //super(code, message, params);\n    //Error.call(this);\n    if (code === undefined) {\n      throw new Error (\"No code supplied for error: \"+ message);\n    }\n    this.message = message;\n    this.params = params;\n    this.code = code;\n    this.dataPath = dataPath || \"\";\n    this.schemaPath = schemaPath || \"\";\n    this.subErrors = subErrors || null;\n\n    const err = new Error(this.message);\n    this.stack = err.stack || err.stacktrace;\n    if (!this.stack) {\n      try {\n        throw err;\n      } catch(err2) {\n        this.stack = err2.stack || err2.stacktrace;\n      }\n    }\n    this.name = \"ValidationError\";\n  };\n\n  prefixWith(dataPrefix, schemaPrefix) {\n    if (dataPrefix !== null) {\n      dataPrefix = dataPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n      this.dataPath = \"/\" + dataPrefix + this.dataPath;\n    }\n    if (schemaPrefix !== null) {\n      schemaPrefix = schemaPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n      this.schemaPath = \"/\" + schemaPrefix + this.schemaPath;\n    }\n    if (this.subErrors !== null) {\n      let i = 0, l = this.subErrors.length;\n      for (i = 0; i < l; i++) {\n        this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);\n      }\n    }\n    return this;\n  };\n};\n\nlet ErrorCodeLookup = {}, key;\nfor (key in ERROR_CODES) {\n  ErrorCodeLookup[ERROR_CODES[key]] = key;\n}\n\nexport { ERROR_CODES, ERROR_MESSAGES_DEFAULT, ValidationError, ErrorCodeLookup };\n","const SCHEMA_HEADER = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"model\",\n  \"description\": \"Generated Schema\",\n  \"type\": \"object\",\n  \"properties\": { }\n};\n\n/**\n * <p>Augmented.Utility.SchemaGenerator<br/>\n *\n * Genrate a schema from a set of data</p>\n * @param {object} data a dataset to produce a schema from\n * @memberof Utility\n */\nconst SchemaGenerator = (data) => {\n  let obj = SCHEMA_HEADER;\n  let i, d, dkey, p, keys = Object.keys(data), l = keys.length;\n  for (i = 0; i < l; i++) {\n    d = keys[i];\n    for (dkey in d) {\n      if (d.hasOwnProperty(dkey)) {\n        p = obj.properties[d] = {};\n\n        let t = (typeof data[d]);\n        if (t === \"object\") {\n          t = (Array.isArray(data[d])) ? \"array\" : \"object\";\n        } else if (t === \"number\") {\n          t = (Number.isInteger(data[d])) ? \"integer\" : \"number\";\n        }\n        p.type = t;\n        p.description = String(d);\n      }\n    }\n  }\n  return obj;\n};\n\nexport default SchemaGenerator;\n","/**\n * @see https://github.com/geraintluff/uri-templates\n * but with all the de-substitution stuff removed\n */\nexport const URI_TEMPLATE_GLOBAL_MODIFIERS = {\n  \"+\": true,\n  \"#\": true,\n  \".\": true,\n  \"/\": true,\n  \";\": true,\n  \"?\": true,\n  \"&\": true\n};\n\nexport const URI_TEMPLATE_SUFFICES = {\n  \"*\": true\n};\n\n// parseURI() and resolveUrl() are from https://gist.github.com/1088850\n// - released as public domain by author (\"Yaffle\") - see comments on\n// gist\nexport const parseURI = (url) => {\n  const m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\n  // authority = '//' + user + ':' + pass '@' + hostname + ':' port\n  return (m ? {\n    href     : m[0] || '',\n    protocol : m[1] || '',\n    authority: m[2] || '',\n    host     : m[3] || '',\n    hostname : m[4] || '',\n    port     : m[5] || '',\n    pathname : m[6] || '',\n    search   : m[7] || '',\n    hash     : m[8] || ''\n  } : null);\n};\n\nexport const removeDotSegments = (input) => {\n  let output = [];\n  input.replace(/^(\\.\\.?(\\/|$))+/, '')\n       .replace(/\\/(\\.(\\/|$))+/g, '/')\n       .replace(/\\/\\.\\.$/, '/../')\n       .replace(/\\/?[^\\/]*/g, function (p) {\n    if (p === '/..') {\n      output.pop();\n    } else {\n      output.push(p);\n    }\n  });\n  return output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\n};\n\nexport const resolveUrl = (base, href) => {// RFC 3986\n  href = parseURI(href || '');\n  base = parseURI(base || '');\n\n  return !href || !base ? null : (href.protocol || base.protocol) +\n  (href.protocol || href.authority ? href.authority : base.authority) +\n  removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +\n  (href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\n  href.hash;\n};\n\nexport const getDocumentUri = (uri) => {\n  return uri.split('#')[0];\n};\n\nexport const isTrustedUrl = (baseUrl, testUrl) => {\n  if(testUrl.substring(0, baseUrl.length) === baseUrl){\n    let remainder = testUrl.substring(baseUrl.length);\n    if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === \"/\") || remainder.charAt(0) === \"#\" || remainder.charAt(0) === \"?\") {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const normSchema = (schema, baseUri) => {\n  if (schema && typeof schema === \"object\") {\n    if (baseUri === undefined) {\n      baseUri = schema.id;\n    } else if (typeof schema.id === \"string\") {\n      baseUri = resolveUrl(baseUri, schema.id);\n      schema.id = baseUri;\n    }\n    if (Array.isArray(schema)) {\n      let i = 0, l = schema.length;\n      for (i = 0; i < l; i++) {\n        normSchema(schema[i], baseUri);\n      }\n    } else {\n      if (typeof schema['$ref'] === \"string\") {\n        schema['$ref'] = resolveUrl(baseUri, schema['$ref']);\n      }\n      for (let key in schema) {\n        if (key !== \"enum\") {\n          normSchema(schema[key], baseUri);\n        }\n      }\n    }\n  }\n};\n","import ValidationFramework from \"./validationFramework.js\";\nimport SchemaGenerator from \"./schemaGenerator.js\";\n\nmodule.exports.ValidationFramework = ValidationFramework;\nmodule.exports.SchemaGenerator = SchemaGenerator;\n","import SchemaGenerator from \"./schemaGenerator.js\";\nimport createApi from \"./api.js\";\nimport { ERROR_MESSAGES_DEFAULT } from \"./validationError.js\";\n\n/**\n * Augmented.ValidationFramework -\n * The Validation Framework Base Wrapper Class.\n * Provides abstraction for base validation build-in library\n */\nclass ValidationFramework {\n  constructor() {\n    this._myValidator = createApi();\n    if (this._myValidator) {\n      this._myValidator.addLanguage(\"en-us\", ERROR_MESSAGES_DEFAULT);  // changed to US\n    }\n  };\n\n  /**\n   * Returns if the framework supports validation\n   * @returns {boolean} Returns true if the framework supports validation\n   */\n  supportsValidation() {\n    return (this._myValidator !== null);\n  };\n\n  /**\n   * Registers a schema to the Framework\n   * @param {string} identity The identity of the schema\n   * @param {object} schema The JSON schema\n   * @returns {boolean} Returns true on success\n   */\n  registerSchema(identity, schema) {\n    return this._myValidator.addSchema(identity, schema);\n  };\n\n  /**\n   * Gets a schema\n   * @param {string} identity The identity of the schema\n   * @returns {object} The JSON schema\n   */\n  getSchema(identity) {\n    return this._myValidator.getSchema(identity);\n  };\n\n  /**\n   * Gets all schemas\n   * @returns {array} all JSON schemas\n   */\n  getSchemas() {\n    return this._myValidator.getSchemaMap();\n  };\n\n  /**\n   * Clears all schemas\n   */\n  clearSchemas() {\n    this._myValidator.dropSchemas();\n  };\n\n  /**\n   * Validates data via a schema\n   * @param {object} data The data to validate\n   * @param {object} schema The JSON schema\n   * @returns {object} Returns the validation object\n   */\n  validate(data, schema) {\n    return this._myValidator.validateMultiple(data, schema);\n  };\n\n  /**\n   * Validates data via a schema\n   * @returns {array} Returns the validation messages\n   */\n  getValidationMessages() {\n    return this._myValidator.error;\n  };\n\n  /**\n   * Validates data via a schema\n   * @param {Augmented.Model|object} model The model generate from\n   * @returns {object} Returns the schema\n   */\n  generateSchema(model) {\n    let data = model;\n    /*TODO support model\n    if (model && model instanceof Model) {\n      data = model.toJSON();\n    }*/\n    return SchemaGenerator(data);\n  };\n};\n\nexport default ValidationFramework;\n","import ValidatorContext from \"./validatorContext.js\";\nimport { ErrorCodeLookup, ERROR_CODES, ERROR_MESSAGES_DEFAULT } from \"./validationError.js\";\nimport { normSchema, resolveUrl, getDocumentUri } from \"./functions.js\";\n\nlet languages = {};\n\nconst createApi = (language) => {\n  const _myContext = new ValidatorContext();\n  let currentLanguage = language || 'en';\n\n  const api = {\n    addFormat: (format, validator) => {\n      _myContext.addFormat(format, validator);\n    },\n    language: (code) => {\n      if (!code) {\n        return currentLanguage;\n      }\n      if (!languages[code]) {\n        code = code.split('-')[0]; // fall back to base\n        // language\n      }\n      if (languages[code]) {\n        currentLanguage = code;\n        return code; // so you can tell if fall-back has happened\n      }\n      return false;\n    },\n    addLanguage: (code, messageMap) => {\n      let key;\n      for (key in ERROR_CODES) {\n        if (messageMap[key] && !messageMap[ERROR_CODES[key]]) {\n          messageMap[ERROR_CODES[key]] = messageMap[key];\n        }\n      }\n      let rootCode = code.split('-')[0];\n      if (!languages[rootCode]) { // use for base language if\n        // not yet defined\n        languages[code] = messageMap;\n        languages[rootCode] = messageMap;\n      } else {\n        languages[code] = Object.create(languages[rootCode]);\n        for (key in messageMap) {\n          if (typeof languages[rootCode][key] === 'undefined') {\n            languages[rootCode][key] = messageMap[key];\n          }\n          languages[code][key] = messageMap[key];\n        }\n      }\n      return this;\n    },\n    freshApi: (language) => {\n      const result = createApi();\n      if (language) {\n        result.language(language);\n      }\n      return result;\n    },\n    validate: (data, schema, checkRecursive, banUnknownProperties) => {\n      const context = new ValidatorContext(_myContext, false, languages[currentLanguage], checkRecursive, banUnknownProperties);\n      if (typeof schema === \"string\") {\n        schema = {\"$ref\": schema};\n      }\n      context.addSchema(\"\", schema);\n      let error = context.validateAll(data, schema, null, null, \"\");\n      if (!error && banUnknownProperties) {\n        error = context.banUnknownProperties();\n      }\n      this.error = error;\n      this.missing = context.missing;\n      this.valid = (error === null);\n      return this.valid;\n    },\n    validateResult: () => {\n      let result = {};\n      this.validate.apply(result, arguments);\n      return result;\n    },\n    validateMultiple: (data, schema, checkRecursive, banUnknownProperties) => {\n      const context = new ValidatorContext(_myContext, true, languages[currentLanguage], checkRecursive, banUnknownProperties);\n      if (typeof schema === \"string\") {\n        schema = {\"$ref\": schema};\n      }\n      context.addSchema(\"\", schema);\n      context.validateAll(data, schema, null, null, \"\");\n      if (banUnknownProperties) {\n        context.banUnknownProperties();\n      }\n      let result = {};\n      result.errors = context.errors;\n      result.missing = context.missing;\n      result.valid = (result.errors.length === 0);\n      return result;\n    },\n    addSchema: (url, schema) => {\n      return _myContext.addSchema(url, schema);\n    },\n    getSchema: (url, urlHistory) => {\n      return _myContext.getSchema(url, urlHistory);\n    },\n    getSchemaMap: () => {\n      return _myContext.getSchemaMap.apply(_myContext, arguments);\n    },\n    getSchemaUris: () => {\n      return _myContext.getSchemaUris.apply(_myContext, arguments);\n    },\n    getMissingUris: () => {\n      return _myContext.getMissingUris.apply(_myContext, arguments);\n    },\n    dropSchemas: () => {\n      _myContext.dropSchemas.apply(_myContext, arguments);\n    },\n    defineKeyword: () => {\n      _myContext.defineKeyword.apply(_myContext, arguments);\n    },\n    defineError: (codeName, codeNumber, defaultMessage) => {\n      if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {\n        // TODO message bundle this\n        throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');\n      }\n      if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {\n        // TODO message bundle this\n        throw new Error('Code number must be an integer > 10000');\n      }\n      if (typeof ERROR_CODES[codeName] !== 'undefined') {\n        // TODO message bundle this\n        throw new Error('Error already defined: ' + codeName + ' as ' + ERROR_CODES[codeName]);\n      }\n      if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {\n        // TODO message bundle this\n        throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);\n      }\n      ERROR_CODES[codeName] = codeNumber;\n      ErrorCodeLookup[codeNumber] = codeName;\n      ERROR_MESSAGES_DEFAULT[codeName] = ERROR_MESSAGES_DEFAULT[codeNumber] = defaultMessage;\n      for (let langCode in languages) {\n        let language = languages[langCode];\n        if (language[codeName]) {\n          language[codeNumber] = language[codeNumber] || language[codeName];\n        }\n      }\n    },\n    reset: () => {\n      _myContext.reset();\n      this.error = null;\n      this.missing = [];\n      this.valid = true;\n    },\n    missing: [],\n    error: null,\n    valid: true,\n    normSchema: normSchema,\n    resolveUrl: resolveUrl,\n    getDocumentUri: getDocumentUri,\n    errorCodes: ERROR_CODES\n  };\n  return api;\n};\n\nexport default createApi;\n","import { ValidationError, ERROR_CODES, ERROR_MESSAGES_DEFAULT } from \"./validationError.js\";\nimport { normSchema, getDocumentUri } from \"./functions.js\";\n\nlet CLOSE_ENOUGH_LOW = Math.pow(2, -51);\nlet CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;\n\nclass ValidatorContext {\n  constructor(parent, collectMultiple, errorMessages, checkRecursive, trackUnknownProperties) {\n    this.missing = [];\n    this.missingMap = {};\n    this.formatValidators = parent ? Object.create(parent.formatValidators) : {};\n    this.schemas = parent ? Object.create(parent.schemas) : {};\n    this.collectMultiple = collectMultiple;\n    this.errors = [];\n    this.handleError = collectMultiple ? this.collectError : this.returnError;\n    if (checkRecursive) {\n      this.checkRecursive = true;\n      this.scanned = [];\n      this.scannedFrozen = [];\n      this.scannedFrozenSchemas = [];\n      this.scannedFrozenValidationErrors = [];\n      this.validatedSchemasKey = 'tv4_validation_id';\n      this.validationErrorsKey = 'tv4_validation_errors_id';\n    }\n    if (trackUnknownProperties) {\n      this.trackUnknownProperties = true;\n      this.knownPropertyPaths = {};\n      this.unknownPropertyPaths = {};\n    }\n    this.errorMessages = errorMessages;\n    this.definedKeywords = {};\n    if (parent) {\n      for (let key in parent.definedKeywords) {\n        this.definedKeywords[key] = parent.definedKeywords[key].slice(0);\n      }\n    }\n  };\n\n  notReallyPercentEncode(string) {\n    return encodeURI(string).replace(/%25[0-9][0-9]/g, (doubleEncoded) => {\n      return \"%\" + doubleEncoded.substring(3);\n    });\n  };\n\n  uriTemplateSubstitution(spec) {\n    let modifier = \"\";\n    if (URI_TEMPLATE_GLOBAL_MODIFIERS[spec.charAt(0)]) {\n      modifier = spec.charAt(0);\n      spec = spec.substring(1);\n    }\n    let separator = \"\";\n    let prefix = \"\";\n    let shouldEscape = true;\n    let showVariables = false;\n    let trimEmptyString = false;\n    if (modifier === '+') {\n      shouldEscape = false;\n    } else if (modifier === \".\") {\n      prefix = \".\";\n      separator = \".\";\n    } else if (modifier === \"/\") {\n      prefix = \"/\";\n      separator = \"/\";\n    } else if (modifier === '#') {\n      prefix = \"#\";\n      shouldEscape = false;\n    } else if (modifier === ';') {\n      prefix = \";\";\n      separator = \";\";\n      showVariables = true;\n      trimEmptyString = true;\n    } else if (modifier === '?') {\n      prefix = \"?\";\n      separator = \"&\";\n      showVariables = true;\n    } else if (modifier === '&') {\n      prefix = \"&\";\n      separator = \"&\";\n      showVariables = true;\n    }\n\n    let varNames = [];\n    let varList = spec.split(\",\");\n    let varSpecs = [];\n    let varSpecMap = {};\n    let i = 0, l = varList.length;\n    for (i = 0; i < l; i++) {\n      let varName = varList[i];\n      let truncate = null;\n      if (varName.indexOf(\":\") !== -1) {\n        let parts = varName.split(\":\");\n        varName = parts[0];\n        truncate = parseInt(parts[1], 10);\n      }\n      let suffices = {};\n      while (URI_TEMPLATE_SUFFICES[varName.charAt(varName.length - 1)]) {\n        suffices[varName.charAt(varName.length - 1)] = true;\n        varName = varName.substring(0, varName.length - 1);\n      }\n      let varSpec = {\n        truncate: truncate,\n        name: varName,\n        suffices: suffices\n      };\n      varSpecs.push(varSpec);\n      varSpecMap[varName] = varSpec;\n      varNames.push(varName);\n    }\n\n    const subFunction = (valueFunction) => {\n      let result = \"\";\n      let startIndex = 0;\n      let i = 0, l = varSpecs.length;\n      for (i = 0; i < l; i++) {\n        let varSpec = varSpecs[i];\n\n        if (!valueFunction && !isFunction(valueFunction)) {\n          throw new Error(\"Problem qith value function.\");\n        }\n\n        let value = valueFunction(varSpec.name);\n        if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {\n          startIndex++;\n          continue;\n        }\n        if (i === startIndex) {\n          result += prefix;\n        } else {\n          result += (separator || \",\");\n        }\n        if (Array.isArray(value)) {\n          if (showVariables) {\n            result += varSpec.name + \"=\";\n          }\n          let j = 0;\n          l = value.length;\n          for (j = 0; j < l; j++) {\n            if (j > 0) {\n              result += varSpec.suffices['*'] ? (separator || \",\") : \",\";\n              if (varSpec.suffices['*'] && showVariables) {\n                result += varSpec.name + \"=\";\n              }\n            }\n            result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, \"%21\") : this.notReallyPercentEncode(value[j]);\n          }\n        } else if (typeof value === \"object\") {\n          if (showVariables && !varSpec.suffices['*']) {\n            result += varSpec.name + \"=\";\n          }\n          let first = true;\n          for (let key in value) {\n            if (!first) {\n              result += varSpec.suffices['*'] ? (separator || \",\") : \",\";\n            }\n            first = false;\n            result += shouldEscape ? encodeURIComponent(key).replace(/!/g, \"%21\") : this.notReallyPercentEncode(key);\n            result += varSpec.suffices['*'] ? '=' : \",\";\n            result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, \"%21\") : this.notReallyPercentEncode(value[key]);\n          }\n        } else {\n          if (showVariables) {\n            result += varSpec.name;\n            if (!trimEmptyString || value !== \"\") {\n              result += \"=\";\n            }\n          }\n          if (varSpec.truncate !== null) {\n            value = value.substring(0, varSpec.truncate);\n          }\n          result += shouldEscape ? encodeURIComponent(value).replace(/!/g, \"%21\"): this.notReallyPercentEncode(value);\n        }\n      }\n      return result;\n    };\n    subFunction.varNames = varNames;\n    return {\n      prefix: prefix,\n      substitution: subFunction\n    };\n  };\n\n  recursiveCompare(A, B) {\n    if (A === B) {\n      return true;\n    }\n    if (typeof A === \"object\" && typeof B === \"object\") {\n      if (Array.isArray(A) !== Array.isArray(B)) {\n        return false;\n      } else if (Array.isArray(A)) {\n        if (A.length !== B.length) {\n          return false;\n        }\n        let i = 0, l = A.length;\n        for (i = 0; i < l; i++) {\n          if (!this.recursiveCompare(A[i], B[i])) {\n            return false;\n          }\n        }\n      } else {\n        let key;\n        for (key in A) {\n          if (B[key] === undefined && A[key] !== undefined) {\n            return false;\n          }\n        }\n        for (key in B) {\n          if (A[key] === undefined && B[key] !== undefined) {\n            return false;\n          }\n        }\n        for (key in A) {\n          if (!this.recursiveCompare(A[key], B[key])) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n\n  defineKeyword(keyword, keywordFunction) {\n    this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];\n    this.definedKeywords[keyword].push(keywordFunction);\n  };\n\n  createError(code, messageParams, dataPath, schemaPath, subErrors) {\n    let messageTemplate = this.errorMessages[code] || ERROR_MESSAGES_DEFAULT[code];\n    if (typeof messageTemplate !== 'string') {\n      return new ValidationError(code, \"Unknown error code \" + code + \": \" + JSON.stringify(messageParams), messageParams, dataPath, schemaPath, subErrors);\n    }\n    // Adapted from Crockford's supplant()\n    let message = messageTemplate.replace(/\\{([^{}]*)\\}/g, function (whole, varName) {\n      let subValue = messageParams[varName];\n      return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;\n    });\n    return new ValidationError(code, message, messageParams, dataPath, schemaPath, subErrors);\n  };\n  returnError(error) {\n    return error;\n  };\n\n  collectError(error) {\n    if (error) {\n      this.errors.push(error);\n    }\n    return null;\n  };\n\n  prefixErrors(startIndex, dataPath, schemaPath) {\n    let i = 0, l = this.errors.length;\n    for (i = startIndex; i < l; i++) {\n      this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);\n    }\n    return this;\n  };\n\n  banUnknownProperties() {\n    for (let unknownPath in this.unknownPropertyPaths) {\n      let error = this.createError(ERROR_CODES.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, \"\");\n      let result = this.handleError(error);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  };\n  addFormat(format, validator) {\n    if (typeof format === 'object') {\n      for (let key in format) {\n        this.addFormat(key, format[key]);\n      }\n      return this;\n    }\n    this.formatValidators[format] = validator;\n  };\n  resolveRefs(schema, urlHistory) {\n    if (schema['$ref'] !== undefined) {\n      urlHistory = urlHistory || {};\n      if (urlHistory[schema['$ref']]) {\n        return this.createError(ERROR_CODES.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '');\n      }\n      urlHistory[schema['$ref']] = true;\n      schema = this.getSchema(schema['$ref'], urlHistory);\n    }\n    return schema;\n  };\n  getSchema(url, urlHistory) {\n    let schema;\n    if (this.schemas[url] !== undefined) {\n      schema = this.schemas[url];\n      return this.resolveRefs(schema, urlHistory);\n    }\n    let baseUrl = url;\n    let fragment = \"\";\n    if (url.indexOf('#') !== -1) {\n      fragment = url.substring(url.indexOf(\"#\") + 1);\n      baseUrl = url.substring(0, url.indexOf(\"#\"));\n    }\n    if (typeof this.schemas[baseUrl] === 'object') {\n      schema = this.schemas[baseUrl];\n      let pointerPath = decodeURIComponent(fragment);\n      if (pointerPath === \"\") {\n        return this.resolveRefs(schema, urlHistory);\n      } else if (pointerPath.charAt(0) !== \"/\") {\n        return undefined;\n      }\n      let parts = pointerPath.split(\"/\").slice(1);\n      let i = 0, l = parts.length;\n      for (i = 0; i < l; i++) {\n        let component = parts[i].replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n        if (schema[component] === undefined) {\n          schema = undefined;\n          break;\n        }\n        schema = schema[component];\n      }\n      if (schema !== undefined) {\n        return this.resolveRefs(schema, urlHistory);\n      }\n    }\n    if (this.missing[baseUrl] === undefined) {\n      this.missing.push(baseUrl);\n      this.missing[baseUrl] = baseUrl;\n      this.missingMap[baseUrl] = baseUrl;\n    }\n  };\n  searchSchemas(schema, url) {\n    if (Array.isArray(schema)) {\n      let i = 0, l = schema.length;\n      for (i = 0; i < l; i++) {\n        this.searchSchemas(schema[i], url);\n      }\n    } else if (schema && typeof schema === \"object\") {\n      if (typeof schema.id === \"string\") {\n        if (isTrustedUrl(url, schema.id)) {\n          if (this.schemas[schema.id] === undefined) {\n            this.schemas[schema.id] = schema;\n          }\n        }\n      }\n      for (let key in schema) {\n        if (key !== \"enum\") {\n          if (typeof schema[key] === \"object\") {\n            this.searchSchemas(schema[key], url);\n          } else if (key === \"$ref\") {\n            let uri = getDocumentUri(schema[key]);\n            if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {\n              this.missingMap[uri] = uri;\n            }\n          }\n        }\n      }\n    }\n  };\n  addSchema(url, schema) {\n    // overload\n    if (typeof url !== 'string' || typeof schema === 'undefined') {\n      if (typeof url === 'object' && typeof url.id === 'string') {\n        schema = url;\n        url = schema.id;\n      } else {\n        return;\n      }\n    }\n    if (url === getDocumentUri(url) + \"#\") {\n      // Remove empty fragment\n      url = getDocumentUri(url);\n    }\n    this.schemas[url] = schema;\n    delete this.missingMap[url];\n    normSchema(schema, url);\n    this.searchSchemas(schema, url);\n  };\n\n  getSchemaMap() {\n    let map = {};\n    for (let key in this.schemas) {\n      map[key] = this.schemas[key];\n    }\n    return map;\n  };\n\n  getSchemaUris(filterRegExp) {\n    let list = [];\n    for (let key in this.schemas) {\n      if (!filterRegExp || filterRegExp.test(key)) {\n        list.push(key);\n      }\n    }\n    return list;\n  };\n\n  getMissingUris(filterRegExp) {\n    let list = [];\n    for (let key in this.missingMap) {\n      if (!filterRegExp || filterRegExp.test(key)) {\n        list.push(key);\n      }\n    }\n    return list;\n  };\n\n  dropSchemas() {\n    this.schemas = {};\n    this.reset();\n  };\n\n  reset() {\n    this.missing = [];\n    this.missingMap = {};\n    this.errors = [];\n  };\n\n  validateAll(data, schema, dataPathParts, schemaPathParts, dataPointerPath) {\n    let topLevel;\n    schema = this.resolveRefs(schema);\n\n    if (!schema) {\n      return null;\n    } else if (schema instanceof ValidationError) {\n      this.errors.push(schema);\n      return schema;\n    }\n\n    let startErrorCount = this.errors.length;\n    let frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;\n    if (this.checkRecursive && data && typeof data === 'object') {\n      topLevel = !this.scanned.length;\n      if (data[this.validatedSchemasKey]) {\n        let schemaIndex = data[this.validatedSchemasKey].indexOf(schema);\n        if (schemaIndex !== -1) {\n          this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);\n          return null;\n        }\n      }\n      if (Object.isFrozen(data)) {\n        frozenIndex = this.scannedFrozen.indexOf(data);\n        if (frozenIndex !== -1) {\n          let frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);\n          if (frozenSchemaIndex !== -1) {\n            this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);\n            return null;\n          }\n        }\n      }\n      this.scanned.push(data);\n      if (Object.isFrozen(data)) {\n        if (frozenIndex === -1) {\n          frozenIndex = this.scannedFrozen.length;\n          this.scannedFrozen.push(data);\n          this.scannedFrozenSchemas.push([]);\n        }\n        scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;\n        this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;\n        this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];\n      } else {\n        if (!data[this.validatedSchemasKey]) {\n          try {\n            Object.defineProperty(data, this.validatedSchemasKey, {\n              value: [],\n              configurable: true\n            });\n            Object.defineProperty(data, this.validationErrorsKey, {\n              value: [],\n              configurable: true\n            });\n          } catch (e) {\n            // IE 7/8 workaround\n            data[this.validatedSchemasKey] = [];\n            data[this.validationErrorsKey] = [];\n          }\n        }\n        scannedSchemasIndex = data[this.validatedSchemasKey].length;\n        data[this.validatedSchemasKey][scannedSchemasIndex] = schema;\n        data[this.validationErrorsKey][scannedSchemasIndex] = [];\n      }\n    }\n\n    let errorCount = this.errors.length;\n    let error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateHypermedia(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;\n\n    if (topLevel) {\n      while (this.scanned.length) {\n        let item = this.scanned.pop();\n        delete item[this.validatedSchemasKey];\n      }\n      this.scannedFrozen = [];\n      this.scannedFrozenSchemas = [];\n    }\n\n    if (error || errorCount !== this.errors.length) {\n      while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {\n        let dataPart = (dataPathParts && dataPathParts.length) ? \"\" + dataPathParts.pop() : null;\n        let schemaPart = (schemaPathParts && schemaPathParts.length) ? \"\" + schemaPathParts.pop() : null;\n        if (error) {\n          error = error.prefixWith(dataPart, schemaPart);\n        }\n        this.prefixErrors(errorCount, dataPart, schemaPart);\n      }\n    }\n\n    if (scannedFrozenSchemaIndex !== null) {\n      this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);\n    } else if (scannedSchemasIndex !== null) {\n      data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);\n    }\n\n    return this.handleError(error);\n  };\n\n  validateFormat(data, schema) {\n    if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {\n      return null;\n    }\n    let errorMessage = this.formatValidators[schema.format].call(null, data, schema);\n    if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {\n      return this.createError(ERROR_CODES.FORMAT_CUSTOM, {message: errorMessage}).prefixWith(null, \"format\");\n    } else if (errorMessage && typeof errorMessage === 'object') {\n      return this.createError(ERROR_CODES.FORMAT_CUSTOM, {message: errorMessage.message || \"?\"}, errorMessage.dataPath || null, errorMessage.schemaPath || \"/format\");\n    }\n    return null;\n  };\n\n  validateDefinedKeywords(data, schema, dataPointerPath) {\n    for (let key in this.definedKeywords) {\n      if (typeof schema[key] === 'undefined') {\n        continue;\n      }\n      let validationFunctions = this.definedKeywords[key];\n      let i = 0, l = validationFunctions.length;\n      for (i = 0; i < l; i++) {\n        let func = validationFunctions[i];\n        let result = func(data, schema[key], schema, dataPointerPath);\n        if (typeof result === 'string' || typeof result === 'number') {\n          return this.createError(ERROR_CODES.KEYWORD_CUSTOM, {key: key, message: result}).prefixWith(null, \"format\");\n        } else if (result && typeof result === 'object') {\n          let code = result.code;\n          if (typeof code === 'string') {\n            if (!ERROR_CODES[code]) {\n              throw new Error('Undefined error code (use defineError): ' + code);\n            }\n            code = ERROR_CODES[code];\n          } else if (typeof code !== 'number') {\n            code = ERROR_CODES.KEYWORD_CUSTOM;\n          }\n          let messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || \"?\"};\n          let schemaPath = result.schemaPath ||( \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1'));\n          return this.createError(code, messageParams, result.dataPath || null, schemaPath);\n        }\n      }\n    }\n    return null;\n  };\n\n  validateBasic(data, schema, dataPointerPath) {\n    let error = this.validateType(data, schema, dataPointerPath);\n    if (error) {\n      return error.prefixWith(null, \"type\");\n    }\n      /*if (error = this.validateEnum(data, schema, dataPointerPath)) {\n      return error.prefixWith(null, \"type\");\n    }*/\n    return null;\n  };\n\n  validateType(data, schema) {\n    if (schema.type === undefined) {\n      return null;\n    }\n    let dataType = typeof data;\n    if (data === null) {\n      dataType = \"null\";\n    } else if (Array.isArray(data)) {\n      dataType = \"array\";\n    }\n    let allowedTypes = schema.type;\n    if (typeof allowedTypes !== \"object\") {\n      allowedTypes = [allowedTypes];\n    }\n\n    let i = 0, l = allowedTypes.length;\n    for (i = 0; i < l; i++) {\n      let type = allowedTypes[i];\n      if (type === dataType || (type === \"integer\" && dataType === \"number\" && (data % 1 === 0))) {\n        return null;\n      }\n    }\n    return this.createError(ERROR_CODES.INVALID_TYPE, {type: dataType, expected: allowedTypes.join(\"/\")});\n  };\n\n  validateEnum(data, schema) {\n    if (schema[\"enum\"] === undefined) {\n      return null;\n    }\n    let i = 0, l = schema[\"enum\"].length;\n    for (i = 0; i < l; i++) {\n      let enumVal = schema[\"enum\"][i];\n      if (this.recursiveCompare(data, enumVal)) {\n        return null;\n      }\n    }\n    return this.createError(ERROR_CODES.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data});\n  };\n\n  validateNumeric(data, schema, dataPointerPath) {\n    return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || this.validateNaN(data, schema, dataPointerPath) || null;\n  };\n\n  validateMultipleOf(data, schema) {\n    let multipleOf = schema.multipleOf || schema.divisibleBy;\n    if (multipleOf === undefined) {\n      return null;\n    }\n    if (typeof data === \"number\") {\n      let remainder = (data/multipleOf)%1;\n      if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {\n        return this.createError(ERROR_CODES.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf});\n      }\n    }\n    return null;\n  };\n\n  validateMinMax(data, schema) {\n    if (typeof data !== \"number\") {\n      return null;\n    }\n    if (schema.minimum !== undefined) {\n      if (data < schema.minimum) {\n        return this.createError(ERROR_CODES.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}).prefixWith(null, \"minimum\");\n      }\n      if (schema.exclusiveMinimum && data === schema.minimum) {\n        return this.createError(ERROR_CODES.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}).prefixWith(null, \"exclusiveMinimum\");\n      }\n    }\n    if (schema.maximum !== undefined) {\n      if (data > schema.maximum) {\n        return this.createError(ERROR_CODES.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}).prefixWith(null, \"maximum\");\n      }\n      if (schema.exclusiveMaximum && data === schema.maximum) {\n        return this.createError(ERROR_CODES.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}).prefixWith(null, \"exclusiveMaximum\");\n      }\n    }\n    return null;\n  };\n\n  validateNaN(data) {\n    if (typeof data !== \"number\") {\n      return null;\n    }\n    if (isNaN(data) === true || data === Infinity || data === -Infinity) {\n      return this.createError(ERROR_CODES.NUMBER_NOT_A_NUMBER, {value: data}).prefixWith(null, \"type\");\n    }\n    return null;\n  };\n\n  validateString(data, schema, dataPointerPath) {\n    return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;\n  };\n\n  validateStringLength(data, schema) {\n    if (typeof data !== \"string\") {\n      return null;\n    }\n    if (schema.minLength !== undefined) {\n      if (data.length < schema.minLength) {\n        return this.createError(ERROR_CODES.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}).prefixWith(null, \"minLength\");\n      }\n    }\n    if (schema.maxLength !== undefined) {\n      if (data.length > schema.maxLength) {\n        return this.createError(ERROR_CODES.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}).prefixWith(null, \"maxLength\");\n      }\n    }\n    return null;\n  };\n\n  validateStringPattern(data, schema) {\n    if (typeof data !== \"string\" || schema.pattern === undefined) {\n      return null;\n    }\n    let regexp = new RegExp(schema.pattern);\n    if (!regexp.test(data)) {\n      return this.createError(ERROR_CODES.STRING_PATTERN, {pattern: schema.pattern}).prefixWith(null, \"pattern\");\n    }\n    return null;\n  };\n  validateArray(data, schema, dataPointerPath) {\n    if (!Array.isArray(data)) {\n      return null;\n    }\n    return this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null;\n  };\n\n  validateArrayLength(data, schema) {\n    let error;\n    if (schema.minItems !== undefined) {\n      if (data.length < schema.minItems) {\n        error = (this.createError(ERROR_CODES.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems})).prefixWith(null, \"minItems\");\n        if (this.handleError(error)) {\n          return error;\n        }\n      }\n    }\n    if (schema.maxItems !== undefined) {\n      if (data.length > schema.maxItems) {\n        error = (this.createError(ERROR_CODES.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems})).prefixWith(null, \"maxItems\");\n        if (this.handleError(error)) {\n          return error;\n        }\n      }\n    }\n    return null;\n  };\n\n  validateArrayUniqueItems(data, schema) {\n    if (schema.uniqueItems) {\n      let i = 0, l = data.length;\n      for (i = 0; i < l; i++) {\n        let j = 0;\n        for (j = i + 1; j < l; j++) {\n          if (recursiveCompare(data[i], data[j])) {\n            let error = (this.createError(ERROR_CODES.ARRAY_UNIQUE, {match1: i, match2: j})).prefixWith(null, \"uniqueItems\");\n            if (this.handleError(error)) {\n              return error;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  validateArrayItems(data, schema, dataPointerPath) {\n    if (schema.items === undefined) {\n      return null;\n    }\n    let error, i;\n    if (Array.isArray(schema.items)) {\n      let l = data.length;\n      for (i = 0; i < l; i++) {\n        if (i < schema.items.length) {\n          if (error = this.validateAll(data[i], schema.items[i], [i], [\"items\", i], dataPointerPath + \"/\" + i)) {\n            return error;\n          }\n        } else if (schema.additionalItems !== undefined) {\n          if (typeof schema.additionalItems === \"boolean\") {\n            if (!schema.additionalItems) {\n              error = (this.createError(ERROR_CODES.ARRAY_ADDITIONAL_ITEMS, {})).prefixWith(\"\" + i, \"additionalItems\");\n              if (this.handleError(error)) {\n                return error;\n              }\n            }\n          } else if (error = this.validateAll(data[i], schema.additionalItems, [i], [\"additionalItems\"], dataPointerPath + \"/\" + i)) {\n            return error;\n          }\n        }\n      }\n    } else {\n      let l = data.length;\n      for (i = 0; i < l; i++) {\n        if (error = this.validateAll(data[i], schema.items, [i], [\"items\"], dataPointerPath + \"/\" + i)) {\n          return error;\n        }\n      }\n    }\n    return null;\n  };\n\n  validateObject(data, schema, dataPointerPath) {\n    if (typeof data !== \"object\" || data === null || Array.isArray(data)) {\n      return null;\n    }\n    return this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;\n  };\n\n  validateObjectMinMaxProperties(data, schema) {\n    let keys = Object.keys(data);\n    let error;\n    if (schema.minProperties !== undefined) {\n      if (keys.length < schema.minProperties) {\n        error = this.createError(ERROR_CODES.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}).prefixWith(null, \"minProperties\");\n        if (this.handleError(error)) {\n          return error;\n        }\n      }\n    }\n    if (schema.maxProperties !== undefined) {\n      if (keys.length > schema.maxProperties) {\n        error = this.createError(ERROR_CODES.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}).prefixWith(null, \"maxProperties\");\n        if (this.handleError(error)) {\n          return error;\n        }\n      }\n    }\n    return null;\n  };\n\n  validateObjectRequiredProperties(data, schema) {\n    if (schema.required !== undefined) {\n      let i = 0, l = schema.required.length;\n      for (i = 0; i < l; i++) {\n        let key = schema.required[i];\n        if (data[key] === undefined) {\n          let error = this.createError(ERROR_CODES.OBJECT_REQUIRED, {key: key}).prefixWith(null, \"\" + i).prefixWith(null, \"required\");\n          if (this.handleError(error)) {\n            return error;\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  validateObjectProperties(data, schema, dataPointerPath) {\n    let error;\n    for (let key in data) {\n      let keyPointerPath = dataPointerPath + \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\n      let foundMatch = false;\n      if (schema.properties !== undefined && schema.properties[key] !== undefined) {\n        foundMatch = true;\n        if (error = this.validateAll(data[key], schema.properties[key], [key], [\"properties\", key], keyPointerPath)) {\n          return error;\n        }\n      }\n      if (schema.patternProperties !== undefined) {\n        for (let patternKey in schema.patternProperties) {\n          let regexp = new RegExp(patternKey);\n          if (regexp.test(key)) {\n            foundMatch = true;\n            if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], [\"patternProperties\", patternKey], keyPointerPath)) {\n              return error;\n            }\n          }\n        }\n      }\n      if (!foundMatch) {\n        if (schema.additionalProperties !== undefined) {\n          if (this.trackUnknownProperties) {\n            this.knownPropertyPaths[keyPointerPath] = true;\n            delete this.unknownPropertyPaths[keyPointerPath];\n          }\n          if (typeof schema.additionalProperties === \"boolean\") {\n            if (!schema.additionalProperties) {\n              error = this.createError(ERROR_CODES.OBJECT_ADDITIONAL_PROPERTIES, {}).prefixWith(key, \"additionalProperties\");\n              if (this.handleError(error)) {\n                return error;\n              }\n            }\n          } else {\n            if (error = this.validateAll(data[key], schema.additionalProperties, [key], [\"additionalProperties\"], keyPointerPath)) {\n              return error;\n            }\n          }\n        } else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {\n          this.unknownPropertyPaths[keyPointerPath] = true;\n        }\n      } else if (this.trackUnknownProperties) {\n        this.knownPropertyPaths[keyPointerPath] = true;\n        delete this.unknownPropertyPaths[keyPointerPath];\n      }\n    }\n    return null;\n  };\n\n  validateObjectDependencies(data, schema, dataPointerPath) {\n    let error;\n    if (schema.dependencies !== undefined) {\n      for (let depKey in schema.dependencies) {\n        if (data[depKey] !== undefined) {\n          let dep = schema.dependencies[depKey];\n          if (typeof dep === \"string\") {\n            if (data[dep] === undefined) {\n              error = this.createError(ERROR_CODES.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n              if (this.handleError(error)) {\n                return error;\n              }\n            }\n          } else if (Array.isArray(dep)) {\n            let i = 0, l = dep.lenth;\n            for (i = 0; i < l; i++) {\n              let requiredKey = dep[i];\n              if (data[requiredKey] === undefined) {\n                error = this.createError(ERROR_CODES.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}).prefixWith(null, \"\" + i).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n                if (this.handleError(error)) {\n                  return error;\n                }\n              }\n            }\n          } else {\n            if (error = this.validateAll(data, dep, [], [\"dependencies\", depKey], dataPointerPath)) {\n              return error;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  validateCombinations(data, schema, dataPointerPath) {\n    return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;\n  };\n\n  validateAllOf(data, schema, dataPointerPath) {\n    if (schema.allOf === undefined) {\n      return null;\n    }\n    let error;\n    let i = 0, l = schema.allOf.length;\n    for (i = 0; i < l; i++) {\n      let subSchema = schema.allOf[i];\n      if (error = this.validateAll(data, subSchema, [], [\"allOf\", i], dataPointerPath)) {\n        return error;\n      }\n    }\n    return null;\n  };\n\n  validateAnyOf(data, schema, dataPointerPath) {\n    if (schema.anyOf === undefined) {\n      return null;\n    }\n    let errors = [];\n    let startErrorCount = this.errors.length;\n    let oldUnknownPropertyPaths, oldKnownPropertyPaths;\n    if (this.trackUnknownProperties) {\n      oldUnknownPropertyPaths = this.unknownPropertyPaths;\n      oldKnownPropertyPaths = this.knownPropertyPaths;\n    }\n    let errorAtEnd = true;\n    let i = 0, l = schema.anyOf.length;\n    for (i = 0; i < l; i++) {\n      if (this.trackUnknownProperties) {\n        this.unknownPropertyPaths = {};\n        this.knownPropertyPaths = {};\n      }\n      let subSchema = schema.anyOf[i];\n\n      let errorCount = this.errors.length;\n      let error = this.validateAll(data, subSchema, [], [\"anyOf\", i], dataPointerPath);\n\n      if (error === null && errorCount === this.errors.length) {\n        this.errors = this.errors.slice(0, startErrorCount);\n\n        if (this.trackUnknownProperties) {\n          for (let knownKey in this.knownPropertyPaths) {\n            oldKnownPropertyPaths[knownKey] = true;\n            delete oldUnknownPropertyPaths[knownKey];\n          }\n          for (let unknownKey in this.unknownPropertyPaths) {\n            if (!oldKnownPropertyPaths[unknownKey]) {\n              oldUnknownPropertyPaths[unknownKey] = true;\n            }\n          }\n          // We need to continue looping so we catch all the\n          // property definitions, but we don't want to return an\n          // error\n          errorAtEnd = false;\n          continue;\n        }\n\n        return null;\n      }\n      if (error) {\n        errors.push(error.prefixWith(null, \"\" + i).prefixWith(null, \"anyOf\"));\n      }\n    }\n    if (this.trackUnknownProperties) {\n      this.unknownPropertyPaths = oldUnknownPropertyPaths;\n      this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n    if (errorAtEnd) {\n      errors = errors.concat(this.errors.slice(startErrorCount));\n      this.errors = this.errors.slice(0, startErrorCount);\n      return this.createError(ERROR_CODES.ANY_OF_MISSING, {}, \"\", \"/anyOf\", errors);\n    }\n  };\n\n  validateOneOf(data, schema, dataPointerPath) {\n    if (schema.oneOf === undefined) {\n      return null;\n    }\n    let validIndex = null;\n    let errors = [];\n    let startErrorCount = this.errors.length;\n    let oldUnknownPropertyPaths, oldKnownPropertyPaths;\n    if (this.trackUnknownProperties) {\n      oldUnknownPropertyPaths = this.unknownPropertyPaths;\n      oldKnownPropertyPaths = this.knownPropertyPaths;\n    }\n    let i = 0, l = schema.oneOf.length;\n    for (i = 0; i < l; i++) {\n      if (this.trackUnknownProperties) {\n        this.unknownPropertyPaths = {};\n        this.knownPropertyPaths = {};\n      }\n      let subSchema = schema.oneOf[i];\n\n      let errorCount = this.errors.length;\n      let error = this.validateAll(data, subSchema, [], [\"oneOf\", i], dataPointerPath);\n\n      if (error === null && errorCount === this.errors.length) {\n        if (validIndex === null) {\n          validIndex = i;\n        } else {\n          this.errors = this.errors.slice(0, startErrorCount);\n          return this.createError(ERROR_CODES.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, \"\", \"/oneOf\");\n        }\n        if (this.trackUnknownProperties) {\n          for (let knownKey in this.knownPropertyPaths) {\n            oldKnownPropertyPaths[knownKey] = true;\n            delete oldUnknownPropertyPaths[knownKey];\n          }\n          for (let unknownKey in this.unknownPropertyPaths) {\n            if (!oldKnownPropertyPaths[unknownKey]) {\n              oldUnknownPropertyPaths[unknownKey] = true;\n            }\n          }\n        }\n      } else if (error) {\n        errors.push(error);\n      }\n    }\n    if (this.trackUnknownProperties) {\n      this.unknownPropertyPaths = oldUnknownPropertyPaths;\n      this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n    if (validIndex === null) {\n      errors = errors.concat(this.errors.slice(startErrorCount));\n      this.errors = this.errors.slice(0, startErrorCount);\n      return this.createError(ERROR_CODES.ONE_OF_MISSING, {}, \"\", \"/oneOf\", errors);\n    } else {\n      this.errors = this.errors.slice(0, startErrorCount);\n    }\n    return null;\n  };\n\n  validateNot(data, schema, dataPointerPath) {\n    if (schema.not === undefined) {\n      return null;\n    }\n    let oldErrorCount = this.errors.length;\n    let oldUnknownPropertyPaths, oldKnownPropertyPaths;\n    if (this.trackUnknownProperties) {\n      oldUnknownPropertyPaths = this.unknownPropertyPaths;\n      oldKnownPropertyPaths = this.knownPropertyPaths;\n      this.unknownPropertyPaths = {};\n      this.knownPropertyPaths = {};\n    }\n    let error = this.validateAll(data, schema.not, null, null, dataPointerPath);\n    let notErrors = this.errors.slice(oldErrorCount);\n    this.errors = this.errors.slice(0, oldErrorCount);\n    if (this.trackUnknownProperties) {\n      this.unknownPropertyPaths = oldUnknownPropertyPaths;\n      this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n    if (error === null && notErrors.length === 0) {\n      return this.createError(ERROR_CODES.NOT_PASSED, {}, \"\", \"/not\");\n    }\n    return null;\n  };\n\n  validateHypermedia(data, schema, dataPointerPath) {\n    if (!schema.links) {\n      return null;\n    }\n    let error;\n    let i = 0, l = schema.links.length;\n    for (i = 0; i < l; i++) {\n      let ldo = schema.links[i];\n      if (ldo.rel === \"describedby\") {\n        let template = new UriTemplate(ldo.href);\n        let allPresent = true;\n        let j = 0, ll = template.varNames.length;\n        for (j = 0; j < ll; j++) {\n          if (!(template.varNames[j] in data)) {\n            allPresent = false;\n            break;\n          }\n        }\n        if (allPresent) {\n          let schemaUrl = template.fillFromObject(data);\n          let subSchema = {\"$ref\": schemaUrl};\n          if (error = this.validateAll(data, subSchema, [], [\"links\", i], dataPointerPath)) {\n            return error;\n          }\n        }\n      }\n    }\n  };\n};\n\nexport default ValidatorContext = ValidatorContext;\n"],"sourceRoot":""}